name: Build bootc images and installable artifacts per changed directory

on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to build (comma-separated)'
        required: true
        default: 'linux/amd64,linux/arm64'
      formats:
        description: 'Export formats (comma-separated)'
        required: true
        default: 'anaconda-iso'
  push:
    branches:
      - main

jobs:
  # Setup job: Parse build parameters + detect changed directories
  setup:
    name: Setup build parameters
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.setup.outputs.platforms }}
      formats: ${{ steps.setup.outputs.formats }}
      matrix: ${{ steps.setup.outputs.matrix }}
      artifact_matrix: ${{ steps.setup.outputs.artifact_matrix }}
      dirs: ${{ steps.setup.outputs.dirs }}
      has_dirs: ${{ steps.setup.outputs.has_dirs }}
      has_artifacts: ${{ steps.setup.outputs.has_artifacts }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install skopeo for artifact detection
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Setup build parameters & detect changed directories
        id: setup
        shell: bash
        run: |
          set -euo pipefail

          # Inputs or defaults
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ github.event.inputs.platforms }}"
            FORMATS="${{ github.event.inputs.formats }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            FORMATS="anaconda-iso"
          fi

          echo "platforms=$PLATFORMS" >> "$GITHUB_OUTPUT"
          echo "formats=$FORMATS" >> "$GITHUB_OUTPUT"

          echo "Building for platforms: $PLATFORMS"
          echo "Building formats: $FORMATS"

          # Function to get allowed platforms for a directory
          get_allowed_platforms() {
            local dir="$1"
            local default_platforms="$2"

            if [ -f "$dir/.buildconfig" ]; then
              # Parse .buildconfig file for platforms
              local config_platforms=$(grep -E '^platforms\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^platforms\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ')
              if [ -n "$config_platforms" ]; then
                echo "$config_platforms"
                return
              fi
            fi

            # Return default platforms if no restriction found
            echo "$default_platforms"
          }

          # Function to get artifact configuration for a directory
          get_artifact_config() {
            local dir="$1"
            local default_formats="$2"
            local dir_platforms="$3"

            local create_artifacts=""
            local artifact_formats=""

            if [ -f "$dir/.buildconfig" ]; then
              # Check if artifacts are explicitly enabled/disabled (default: auto)
              create_artifacts=$(grep -E '^artifacts\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^artifacts\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ' || echo "")

              # Get artifact formats if specified
              artifact_formats=$(grep -E '^artifact_formats\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^artifact_formats\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ' || echo "")
            fi

            # Set default value for artifacts if not specified
            if [ -z "$create_artifacts" ]; then
              create_artifacts="auto"
            fi

            # Set default artifact formats if none specified but artifacts are enabled
            if [ -z "$artifact_formats" ] && [ "$create_artifacts" != "false" ]; then
              artifact_formats="$default_formats"
            fi

            # Use pipe as delimiter to avoid comma conflicts with format lists
            echo "$create_artifacts|$artifact_formats|$dir_platforms"
          }

          # Function to check if artifacts exist for an image
          check_existing_artifacts() {
            local image_base="$1"
            local artifact_formats="$2"
            
            # Check each artifact format separately
            IFS=',' read -ra FORMAT_ARRAY <<< "$artifact_formats"
            
            for format in "${FORMAT_ARRAY[@]}"; do
              local artifact_image_base="${image_base}-${format}"
              local existing_tags=""
              
              if skopeo list-tags "docker://${artifact_image_base}" >/tmp/check_tags_${format}.json 2>/dev/null; then
                existing_tags=$(jq -r '.Tags[]' /tmp/check_tags_${format}.json 2>/dev/null | \
                  grep -E '^v[0-9]+(-[^-]+)?$' || echo "")
                
                if [ -n "$existing_tags" ]; then
                  echo "true"
                  return 0
                fi
              fi
            done
            
            echo "false"
          }

          # Detect changed top-level directories between the previous and current commit (push)
          # and for workflow_dispatch, consider ALL top-level dirs that contain a Containerfile.
          if [ "${{ github.event_name }}" = "push" ]; then
            BEFORE="${{ github.event.before }}"
            AFTER="${{ github.sha }}"
            echo "Diff range: $BEFORE..$AFTER"
            CHANGED_DIRS=$(git diff --name-status "$BEFORE" "$AFTER" | awk '{print $2}' | awk -F/ 'NF>1{print $1}' | sort -u)
          else
            # For manual runs, find all top-level dirs with a Containerfile
            CHANGED_DIRS=$(find . -maxdepth 2 -type f -name 'Containerfile' -printf '%h\n' | sed 's#^\./##' | awk -F/ '{print $1}' | sort -u)
          fi

          echo "Changed top-level dirs (raw): $CHANGED_DIRS"

          # Keep only those that currently exist AND contain a Containerfile
          BUILD_DIRS=()
          for d in $CHANGED_DIRS; do
            if [ -f "$d/Containerfile" ]; then
              BUILD_DIRS+=("$d")
            else
              echo "Skipping $d (no Containerfile or directory deleted)"
            fi
          done

          echo "Final build directories: ${BUILD_DIRS[*]}"

          # Set outputs based on whether we have directories to build
          if [ ${#BUILD_DIRS[@]} -eq 0 ]; then
            echo "No buildable directories detected. The workflow will skip build & manifest steps."
            echo 'has_dirs=false' >> "$GITHUB_OUTPUT"
            echo 'has_artifacts=false' >> "$GITHUB_OUTPUT"
            echo 'dirs=[]' >> "$GITHUB_OUTPUT"
            echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            echo 'artifact_matrix={"include":[]}' >> "$GITHUB_OUTPUT"
          else
            echo 'has_dirs=true' >> "$GITHUB_OUTPUT"
            # JSON array of directories for later jobs
            printf 'dirs=[' >> "$GITHUB_OUTPUT"
            for i in "${!BUILD_DIRS[@]}"; do
              [ $i -gt 0 ] && printf ',' >> "$GITHUB_OUTPUT"
              printf '"%s"' "${BUILD_DIRS[$i]}" >> "$GITHUB_OUTPUT"
            done
            printf ']\n' >> "$GITHUB_OUTPUT"

            # Build the cross-product matrix (platform Ã— directory) with architecture restrictions
            MATRIX='{"include":['
            ARTIFACT_MATRIX='{"include":['
            IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
            IFS=',' read -ra FORMAT_ARRAY <<< "$FORMATS"

            first=1
            artifact_first=1
            has_any_artifacts=false

            for DIR in "${BUILD_DIRS[@]:-}"; do
              [ -z "$DIR" ] && continue

              # Get allowed platforms for this directory (same for both images and artifacts)
              ALLOWED_PLATFORMS=$(get_allowed_platforms "$DIR" "$PLATFORMS")
              echo "Directory $DIR platforms: $ALLOWED_PLATFORMS"

              IFS=',' read -ra ALLOWED_PLATFORM_ARRAY <<< "$ALLOWED_PLATFORMS"

              for PLATFORM in "${ALLOWED_PLATFORM_ARRAY[@]}"; do
                # Check if this platform is in the global platform list
                PLATFORM_FOUND=false
                for GLOBAL_PLATFORM in "${PLATFORM_ARRAY[@]}"; do
                  if [ "$PLATFORM" = "$GLOBAL_PLATFORM" ]; then
                    PLATFORM_FOUND=true
                    break
                  fi
                done

                if [ "$PLATFORM_FOUND" = false ]; then
                  echo "Platform $PLATFORM for $DIR not in global platform list, skipping"
                  continue
                fi

                ARCH="${PLATFORM#linux/}"
                if [ "$ARCH" = "arm64" ]; then
                  RUNNER="ubuntu-24.04-arm"
                else
                  RUNNER="ubuntu-latest"
                fi

                if [ $first -eq 0 ]; then MATRIX+=","; fi
                first=0
                MATRIX+="{\"platform\":\"$PLATFORM\",\"arch\":\"$ARCH\",\"runner\":\"$RUNNER\",\"dir\":\"$DIR\"}"
              done

              # Handle artifact configuration
              IMAGE_BASE="${{ vars.DEST_REGISTRY_HOST || 'ghcr.io' }}/${{ vars.DEST_REGISTRY_USER || github.repository_owner }}/bootc-$DIR"
              ARTIFACT_CONFIG=$(get_artifact_config "$DIR" "$FORMATS" "$ALLOWED_PLATFORMS")
              IFS='|' read -ra CONFIG_PARTS <<< "$ARTIFACT_CONFIG"
              CREATE_ARTIFACTS="${CONFIG_PARTS[0]}"
              ARTIFACT_FORMATS="${CONFIG_PARTS[1]:-$FORMATS}"
              ARTIFACT_PLATFORMS="${CONFIG_PARTS[2]}"


              echo "Directory $DIR artifact config - create: $CREATE_ARTIFACTS, formats: $ARTIFACT_FORMATS, platforms: $ARTIFACT_PLATFORMS"

              # Determine if we should create artifacts
              SHOULD_CREATE=false
              if [ "$CREATE_ARTIFACTS" = "true" ]; then
                SHOULD_CREATE=true
              elif [ "$CREATE_ARTIFACTS" = "false" ]; then
                SHOULD_CREATE=false
              elif [ "$CREATE_ARTIFACTS" = "auto" ]; then
                # Check if artifacts already exist
                EXISTING_ARTIFACTS=$(check_existing_artifacts "$IMAGE_BASE" "$ARTIFACT_FORMATS")
                if [ "$EXISTING_ARTIFACTS" = "false" ]; then
                  SHOULD_CREATE=true
                  # Use default format if none specified
                  if [ -z "$ARTIFACT_FORMATS" ]; then
                    ARTIFACT_FORMATS="anaconda-iso"
                  fi
                else
                  echo "Artifacts already exist for $DIR, skipping auto-creation"
                fi
              fi

              if [ "$SHOULD_CREATE" = true ]; then
                has_any_artifacts=true
                IFS=',' read -ra ARTIFACT_FORMAT_ARRAY <<< "$ARTIFACT_FORMATS"
                IFS=',' read -ra ARTIFACT_PLATFORM_ARRAY <<< "$ARTIFACT_PLATFORMS"

                for ARTIFACT_PLATFORM in "${ARTIFACT_PLATFORM_ARRAY[@]}"; do
                  # Check if this platform is in the global platform list
                  PLATFORM_FOUND=false
                  for GLOBAL_PLATFORM in "${PLATFORM_ARRAY[@]}"; do
                    if [ "$ARTIFACT_PLATFORM" = "$GLOBAL_PLATFORM" ]; then
                      PLATFORM_FOUND=true
                      break
                    fi
                  done

                  if [ "$PLATFORM_FOUND" = false ]; then
                    echo "Artifact platform $ARTIFACT_PLATFORM for $DIR not in global platform list, skipping"
                    continue
                  fi

                  ARTIFACT_ARCH="${ARTIFACT_PLATFORM#linux/}"
                  if [ "$ARTIFACT_ARCH" = "arm64" ]; then
                    ARTIFACT_RUNNER="ubuntu-24.04-arm"
                  else
                    ARTIFACT_RUNNER="ubuntu-latest"
                  fi

                  for ARTIFACT_FORMAT in "${ARTIFACT_FORMAT_ARRAY[@]}"; do
                    if [ $artifact_first -eq 0 ]; then ARTIFACT_MATRIX+=","; fi
                    artifact_first=0
                    ARTIFACT_MATRIX+="{\"platform\":\"$ARTIFACT_PLATFORM\",\"arch\":\"$ARTIFACT_ARCH\",\"runner\":\"$ARTIFACT_RUNNER\",\"dir\":\"$DIR\",\"format\":\"$ARTIFACT_FORMAT\"}"
                  done
                done
              fi
            done

            MATRIX+=']}'
            ARTIFACT_MATRIX+=']}'

            echo "Final Matrix: $MATRIX"
            echo "Final Artifact Matrix: $ARTIFACT_MATRIX"

            if [ "$has_any_artifacts" = true ]; then
              echo 'has_artifacts=true' >> "$GITHUB_OUTPUT"
            else
              echo 'has_artifacts=false' >> "$GITHUB_OUTPUT"
            fi

            echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
            echo "artifact_matrix=$ARTIFACT_MATRIX" >> "$GITHUB_OUTPUT"
          fi

          echo "=== Setup script completed successfully ==="

  # Matrix job: Build the bootc image for each (directory, platform)
  build-image:
    name: Build ${{ matrix.dir }} (${{ matrix.arch }})
    needs: setup
    if: needs.setup.outputs.has_dirs == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      image: ${{ steps.build.outputs.image }}
      tags: ${{ steps.build.outputs.tags }}
    env:
      # Disable Subscription Manager container passthrough
      SMDEV_CONTAINER_OFF: 1
      # Source registry for base image
      SOURCE_REGISTRY_HOST: "registry.redhat.io"

      # Destination registry configuration (image name will be per-directory)
      DEST_REGISTRY_HOST: "${{ vars.DEST_REGISTRY_HOST || 'ghcr.io' }}"
      DEST_REGISTRY_USER: "${{ vars.DEST_REGISTRY_USER || github.repository_owner }}"
      DEST_REGISTRY_PASSWORD: "${{ secrets.DEST_REGISTRY_PASSWORD || secrets.GITHUB_TOKEN }}"
    container:
      image: registry.access.redhat.com/ubi9/ubi
      options: --privileged
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get container tools in UBI builder
        run: dnf -y install podman buildah skopeo jq

      - name: Register with Red Hat subscription manager
        run: |
          if [ -n "${{ secrets.RHT_ORGID }}" ] && [ -n "${{ secrets.RHT_ACT_KEY }}" ]; then
            echo "Registering with organization ID and activation key..."
            subscription-manager register --org=${{ secrets.RHT_ORGID }} --activationkey=${{ secrets.RHT_ACT_KEY }}
          else
            echo "Registering with username and password..."
            subscription-manager register --username=${{ secrets.RH_USERNAME }} --password=${{ secrets.RH_PASSWORD }}
          fi

      # workaround for https://github.com/redhat-actions/podman-login/issues/42
      - name: Workaround open podman-login action issue
        env:
          auth: "{ \"auths\": {} }"
        run: |
          mkdir -p $HOME/.docker
          echo "$auth" > $HOME/.docker/config.json

      - name: Log in to Red Hat Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.SOURCE_REGISTRY_HOST }}
          username: ${{ secrets.SOURCE_REGISTRY_USER || secrets.RH_USERNAME }}
          password: ${{ secrets.SOURCE_REGISTRY_PASSWORD || secrets.RH_PASSWORD }}
          auth_file_path: /run/containers/0/auth.json

      - name: Compute semantic version tag (vN) for ${{ matrix.dir }}
        id: version
        shell: bash
        run: |
          set -euo pipefail

          IMAGE_NAME="bootc-${{ matrix.dir }}"
          IMAGE_BASE="${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/${IMAGE_NAME}"

          echo "Determining version for: $IMAGE_BASE"

          # Get existing tags from the registry using skopeo
          EXISTING_TAGS=""
          if skopeo list-tags "docker://${IMAGE_BASE}" >/tmp/tags.json 2>/dev/null; then
            EXISTING_TAGS=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | \
              grep -oE '^v[0-9]+$' | \
              sort -V || echo "")
            echo "Found existing tags: $EXISTING_TAGS"
          else
            echo "No existing tags found or repository doesn't exist yet"
          fi

          if [ -z "$EXISTING_TAGS" ]; then
            echo "No existing version tags found, starting with v1"
            NEXT_TAG="v1"
          else
            # Find the highest version number
            HIGHEST_VERSION=$(echo "$EXISTING_TAGS" | tail -n1)
            HIGHEST_NUM=$(echo "$HIGHEST_VERSION" | sed 's/v//')
            NEXT_NUM=$((HIGHEST_NUM + 1))
            NEXT_TAG="v${NEXT_NUM}"
            echo "Highest existing version: $HIGHEST_VERSION, next version: $NEXT_TAG"
          fi

          echo "NEXT_TAG=$NEXT_TAG" | tee -a "$GITHUB_ENV"
          echo "next=$NEXT_TAG" >> "$GITHUB_OUTPUT"

      - name: Build platform-specific image with Buildah
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: ${{ env.DEST_REGISTRY_USER }}/bootc-${{ matrix.dir }}
          tags: |
            latest-${{ matrix.arch }}
            ${{ github.sha }}-${{ matrix.arch }}
            ${{ steps.version.outputs.next }}-${{ matrix.arch }}
          platforms: ${{ matrix.platform }}
          context: ./${{ matrix.dir }}
          containerfiles: |
            ./${{ matrix.dir }}/Containerfile

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.DEST_REGISTRY_HOST }}
          username: ${{ env.DEST_REGISTRY_USER }}
          password: ${{ env.DEST_REGISTRY_PASSWORD }}
          auth_file_path: /run/containers/0/auth.json

      - name: Push platform-specific image to GHCR
        id: push
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build.outputs.image }}
          tags: ${{ steps.build.outputs.tags }}
          registry: ${{ env.DEST_REGISTRY_HOST }}

      - name: Clean up the subscription
        if: always()
        run: subscription-manager unregister

# Matrix job: Build installable artifacts for each (directory, platform, format)
  build-artifacts:
    name: Build ${{ matrix.dir }} artifacts (${{ matrix.arch }}, ${{ matrix.format }})
    needs: [setup, build-image]
    if: needs.setup.outputs.has_artifacts == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.artifact_matrix) }}
    runs-on: ${{ matrix.runner }}
    env:
      # Disable Subscription Manager container passthrough
      SMDEV_CONTAINER_OFF: 1
      # Destination registry configuration
      DEST_REGISTRY_HOST: "${{ vars.DEST_REGISTRY_HOST || 'ghcr.io' }}"
      DEST_REGISTRY_USER: "${{ vars.DEST_REGISTRY_USER || github.repository_owner }}"
      DEST_REGISTRY_PASSWORD: "${{ secrets.DEST_REGISTRY_PASSWORD || secrets.GITHUB_TOKEN }}"
    container:
      image: quay.io/centos-bootc/bootc-image-builder:latest
      options: --privileged --user root
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get container tools in UBI builder
        run: |
          dnf -y install podman buildah skopeo jq 
          dnf clean all

      - name: Register with Red Hat subscription manager
        run: |
          if [ -n "${{ secrets.RHT_ORGID }}" ] && [ -n "${{ secrets.RHT_ACT_KEY }}" ]; then
            echo "Registering with organization ID and activation key..."
            subscription-manager register --org=${{ secrets.RHT_ORGID }} --activationkey=${{ secrets.RHT_ACT_KEY }}
          else
            echo "Registering with username and password..."
            subscription-manager register --username=${{ secrets.RH_USERNAME }} --password=${{ secrets.RH_PASSWORD }}
          fi

      # workaround for https://github.com/redhat-actions/podman-login/issues/42
      - name: Workaround open podman-login action issue
        env:
          auth: "{ \"auths\": {} }"
        run: |
          mkdir -p $HOME/.docker
          echo "$auth" > $HOME/.docker/config.json

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.DEST_REGISTRY_HOST }}
          username: ${{ env.DEST_REGISTRY_USER }}
          password: ${{ env.DEST_REGISTRY_PASSWORD }}
          auth_file_path: /run/containers/0/auth.json

      - name: Determine image version
        id: version
        shell: bash
        run: |
          set -euo pipefail

          IMAGE_NAME="bootc-${{ matrix.dir }}"
          IMAGE_BASE="${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/${IMAGE_NAME}"

          echo "Determining version for: $IMAGE_BASE"

          # Get existing tags from the registry using skopeo
          EXISTING_TAGS=""
          if skopeo list-tags "docker://${IMAGE_BASE}" >/tmp/tags.json 2>/dev/null; then
            EXISTING_TAGS=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | \
              grep -oE '^v[0-9]+$' | \
              sort -V || echo "")
            echo "Found existing tags: $EXISTING_TAGS"
          else
            echo "No existing tags found or repository doesn't exist yet"
          fi

          if [ -z "$EXISTING_TAGS" ]; then
            echo "No existing version tags found, starting with v1"
            CURRENT_TAG="v1"
          else
            # Find the highest version number - this should be the one just built
            HIGHEST_VERSION=$(echo "$EXISTING_TAGS" | tail -n1)
            # Check if platform-specific tag exists for incremented version
            HIGHEST_NUM=$(echo "$HIGHEST_VERSION" | sed 's/v//')
            INCREMENTED_VERSION="v$((HIGHEST_NUM + 1))"

            if skopeo inspect "docker://${IMAGE_BASE}:${INCREMENTED_VERSION}-${{ matrix.arch }}" >/dev/null 2>&1; then
              CURRENT_TAG="$INCREMENTED_VERSION"
              echo "Using incremented version: $CURRENT_TAG"
            else
              CURRENT_TAG="$HIGHEST_VERSION"
              echo "Using highest existing version: $CURRENT_TAG"
            fi
          fi

          echo "VERSION_TAG=$CURRENT_TAG" | tee -a "$GITHUB_ENV"
          echo "version=$CURRENT_TAG" >> "$GITHUB_OUTPUT"

      - name: Pull bootc image for artifact creation
        run: |
          IMAGE="${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-${{ matrix.dir }}:${{ steps.version.outputs.version }}-${{ matrix.arch }}"
          echo "Pulling bootc image: $IMAGE"
          podman pull "$IMAGE"

      - name: Check available disk space
        run: |
          echo "=== Disk space before cleanup ==="
          df -h

      - name: Create bootc artifact with bootc-image-builder
        run: |
          set -euo pipefail

          IMAGE="${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-${{ matrix.dir }}:${{ steps.version.outputs.version }}-${{ matrix.arch }}"
          mkdir -p output

          echo "Creating ${{ matrix.format }} artifact for $IMAGE"

          # Run bootc-image-builder
          podman run \
            --rm \
            --privileged \
            --pull=newer \
            --security-opt label=type:unconfined_t \
            -v ./output:/output \
            -v /var/lib/containers/storage:/var/lib/containers/storage \
            quay.io/centos-bootc/bootc-image-builder:latest \
            --type ${{ matrix.format }} \
            --use-librepo=True \
            "$IMAGE"

          # List created files
          echo "Created artifacts:"
          ls -la output/

          # Verify we have the expected output
          if [ ! "$(ls -A output/)" ]; then
            echo "ERROR: No artifacts were created!"
            exit 1
          fi

      - name: Create scratch container image with artifact
        id: artifact_image
        run: |
          set -euo pipefail

          ARTIFACT_IMAGE_NAME="${{ env.DEST_REGISTRY_USER }}/bootc-${{ matrix.dir }}-${{ matrix.format }}"
          ARTIFACT_IMAGE_TAG="${{ steps.version.outputs.version }}-${{ matrix.arch }}"

          echo "Creating scratch image: $ARTIFACT_IMAGE_NAME:$ARTIFACT_IMAGE_TAG"

          # Create a simple Containerfile for the scratch image
          cat > Containerfile.artifact << 'EOF'
          FROM scratch
          COPY output/ /
          EOF

          # Build the scratch image containing the artifacts
          buildah bud \
            --tag "$ARTIFACT_IMAGE_NAME:$ARTIFACT_IMAGE_TAG" \
            --file Containerfile.artifact \
            .

          echo "artifact_image=$ARTIFACT_IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "artifact_tag=$ARTIFACT_IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Push artifact image to registry
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.artifact_image.outputs.artifact_image }}
          tags: ${{ steps.artifact_image.outputs.artifact_tag }}
          registry: ${{ env.DEST_REGISTRY_HOST }}

      - name: Clean up the subscription
        if: always()
        run: subscription-manager unregister

  # Job: Create multi-platform manifests for each changed directory
  create-manifest:
    name: Create multi-platform manifests
    needs: [setup, build-image]
    if: needs.setup.outputs.has_dirs == 'true'
    runs-on: ubuntu-latest
    env:
      DEST_REGISTRY_HOST: "${{ vars.DEST_REGISTRY_HOST || 'ghcr.io' }}"
      DEST_REGISTRY_USER: "${{ vars.DEST_REGISTRY_USER || github.repository_owner }}"
      DEST_REGISTRY_PASSWORD: "${{ secrets.DEST_REGISTRY_PASSWORD || secrets.GITHUB_TOKEN }}"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.DEST_REGISTRY_HOST }}
          username: ${{ env.DEST_REGISTRY_USER }}
          password: ${{ env.DEST_REGISTRY_PASSWORD }}

      - name: Install skopeo for version computation
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Create and push multi-platform manifests per directory
        shell: bash
        run: |
          set -euo pipefail

          # Function to get allowed platforms for a directory
          get_allowed_platforms() {
            local dir="$1"
            local default_platforms="$2"

            if [ -f "$dir/.buildconfig" ]; then
              # Parse .buildconfig file for platforms
              local config_platforms=$(grep -E '^platforms\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^platforms\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ')
              if [ -n "$config_platforms" ]; then
                echo "$config_platforms"
                return
              fi
            fi

            # Return default platforms if no restriction found
            echo "$default_platforms"
          }

          IFS=',' read -ra GLOBAL_PLATFORM_ARRAY <<< "${{ needs.setup.outputs.platforms }}"

          # Iterate directories detected in setup (JSON array)
          DIRS_JSON='${{ needs.setup.outputs.dirs }}'
          echo "Directories to process: $DIRS_JSON"

          # Convert JSON array to bash array
          DIRS_CLEAN=$(echo "$DIRS_JSON" | sed 's/\[//g; s/\]//g; s/"//g')
          IFS=',' read -ra DIRS <<< "$DIRS_CLEAN"

          for DIR in "${DIRS[@]}"; do
            IMAGE_BASE="${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-$DIR"

            echo "\n=== Processing bootc-$DIR ==="

            # Get allowed platforms for this directory
            ALLOWED_PLATFORMS=$(get_allowed_platforms "$DIR" "${{ needs.setup.outputs.platforms }}")
            echo "Directory $DIR platforms: $ALLOWED_PLATFORMS"

            # Filter allowed platforms to only include those that were actually built
            IFS=',' read -ra ALLOWED_PLATFORM_ARRAY <<< "$ALLOWED_PLATFORMS"
            BUILT_PLATFORMS=()

            for PLATFORM in "${ALLOWED_PLATFORM_ARRAY[@]}"; do
              # Check if this platform is in the global platform list
              PLATFORM_FOUND=false
              for GLOBAL_PLATFORM in "${GLOBAL_PLATFORM_ARRAY[@]}"; do
                if [ "$PLATFORM" = "$GLOBAL_PLATFORM" ]; then
                  PLATFORM_FOUND=true
                  break
                fi
              done

              if [ "$PLATFORM_FOUND" = true ]; then
                BUILT_PLATFORMS+=("$PLATFORM")
              fi
            done

            if [ ${#BUILT_PLATFORMS[@]} -eq 0 ]; then
              echo "No valid platforms found for $DIR, skipping manifest creation"
              continue
            fi

            echo "Creating manifests for platforms: ${BUILT_PLATFORMS[*]}"

            # Compute the SAME version that was used in the build step
            # This must match exactly what the build step computed
            EXISTING_TAGS=""
            if skopeo list-tags "docker://${IMAGE_BASE}" >/tmp/tags.json 2>/dev/null; then
              # Filter out platform-specific tags to get only base version tags
              EXISTING_TAGS=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | \
                grep -oE '^v[0-9]+' | sort -V || echo "")
              echo "Found existing base version tags: $EXISTING_TAGS"
            else
              echo "No existing tags found"
            fi

            if [ -z "$EXISTING_TAGS" ]; then
              echo "No existing version tags found, using v1"
              VERSION_TAG="v1"
            else
              # Find the highest version number - this should be the one just built
              HIGHEST_VERSION=$(echo "$EXISTING_TAGS" | tail -n1)
              HIGHEST_NUM=$(echo "$HIGHEST_VERSION" | sed 's/v//')
              NEXT_VERSION="v$((HIGHEST_NUM + 1))"

              # Check if the platform-specific tags exist for the next version
              PLATFORM_CHECK="${BUILT_PLATFORMS[0]#linux/}"
              if skopeo inspect "docker://${IMAGE_BASE}:${NEXT_VERSION}-${PLATFORM_CHECK}" >/dev/null 2>&1; then
                VERSION_TAG="$NEXT_VERSION"
                echo "Using incremented version: $VERSION_TAG"
              else
                VERSION_TAG="$HIGHEST_VERSION"
                echo "Using highest existing version: $VERSION_TAG"
              fi
            fi

            # Create manifests for each tag type
            for TAG_TYPE in "latest" "${{ github.sha }}" "$VERSION_TAG"; do
              echo "Creating manifest for $IMAGE_BASE:$TAG_TYPE"

              # Build the manifest create command
              MANIFEST_IMAGES=()
              for PLATFORM in "${BUILT_PLATFORMS[@]}"; do
                ARCH="${PLATFORM#linux/}"
                MANIFEST_IMAGES+=("$IMAGE_BASE:$TAG_TYPE-$ARCH")
              done

              # Create and push the manifest
              podman manifest create "$IMAGE_BASE:$TAG_TYPE"
              for MANIFEST_IMAGE in "${MANIFEST_IMAGES[@]}"; do
                echo "Adding $MANIFEST_IMAGE to manifest"
                podman manifest add "$IMAGE_BASE:$TAG_TYPE" "$MANIFEST_IMAGE"
              done

              echo "Pushing manifest $IMAGE_BASE:$TAG_TYPE"
              podman manifest push "$IMAGE_BASE:$TAG_TYPE" "docker://$IMAGE_BASE:$TAG_TYPE"

              # Clean up local manifest
              podman manifest rm "$IMAGE_BASE:$TAG_TYPE" || true
            done
          done

  # Summary job
  summary:
    name: Build Summary
    needs: [setup, build-image, create-manifest]
    runs-on: ubuntu-latest
    if: always()
    env:
      DEST_REGISTRY_HOST: "${{ vars.DEST_REGISTRY_HOST || 'ghcr.io' }}"
      DEST_REGISTRY_USER: "${{ vars.DEST_REGISTRY_USER || github.repository_owner }}"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Print build summary
        shell: bash
        run: |
          # Function to get allowed platforms for a directory
          get_allowed_platforms() {
            local dir="$1"
            local default_platforms="$2"

            if [ -f "$dir/.buildconfig" ]; then
              # Parse .buildconfig file for platforms
              local config_platforms=$(grep -E '^platforms\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^platforms\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ')
              if [ -n "$config_platforms" ]; then
                echo "$config_platforms"
                return
              fi
            fi

            # Return default platforms if no restriction found
            echo "$default_platforms"
          }

          # Function to get artifact configuration for a directory
          get_artifact_config() {
            local dir="$1"
            local default_formats="${{ needs.setup.outputs.formats }}"

            local create_artifacts=""
            local artifact_formats=""

            if [ -f "$dir/.buildconfig" ]; then
              create_artifacts=$(grep -E '^artifacts\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^artifacts\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ' || echo "")
              artifact_formats=$(grep -E '^artifact_formats\s*[:=]\s*' "$dir/.buildconfig" | sed -E 's/^artifact_formats\s*[:=]\s*//' | tr -d '"'"'" | tr -d ' ' || echo "")
            fi

            # Set default for artifacts if not specified
            if [ -z "$create_artifacts" ]; then
              create_artifacts="auto"
            fi

            echo "$create_artifacts,$artifact_formats"
          }

          echo "## Build Summary" >> "$GITHUB_STEP_SUMMARY"
          if [ "${{ needs.setup.outputs.has_dirs }}" != "true" ]; then
            echo "No buildable directory changes detected in this run." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "### Global Configuration" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Platforms**: ${{ needs.setup.outputs.platforms }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Formats**: ${{ needs.setup.outputs.formats }}" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          DIRS_JSON='${{ needs.setup.outputs.dirs }}'
          # Remove brackets and quotes, split by comma
          DIRS_CLEAN=$(echo "$DIRS_JSON" | sed 's/\[//g; s/\]//g; s/"//g')
          IFS=',' read -ra DIRS <<< "$DIRS_CLEAN"

          echo "### Bootc Images Built" >> "$GITHUB_STEP_SUMMARY"
          for DIR in "${DIRS[@]}"; do
            ALLOWED_PLATFORMS=$(get_allowed_platforms "$DIR" "${{ needs.setup.outputs.platforms }}")
            if [ "$ALLOWED_PLATFORMS" != "${{ needs.setup.outputs.platforms }}" ]; then
              echo "- **$DIR** (platforms: $ALLOWED_PLATFORMS): \`${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-$DIR:{latest | ${{ github.sha }} | vN}\`" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "- **$DIR**: \`${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-$DIR:{latest | ${{ github.sha }} | vN}\`" >> "$GITHUB_STEP_SUMMARY"
            fi
          done

          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ needs.setup.outputs.has_artifacts }}" = "true" ]; then
            echo "### Installable Artifacts Built" >> "$GITHUB_STEP_SUMMARY"

            # Parse the artifact matrix to show what was built
            ARTIFACT_MATRIX_JSON='${{ needs.setup.outputs.artifact_matrix }}'

            # Group by directory and show formats/platforms
            for DIR in "${DIRS[@]}"; do
              ARTIFACT_CONFIG=$(get_artifact_config "$DIR" "$FORMATS" "$ALLOWED_PLATFORMS")
              IFS='|' read -ra CONFIG_PARTS <<< "$ARTIFACT_CONFIG"
              CREATE_ARTIFACTS="${CONFIG_PARTS[0]}"
              ARTIFACT_FORMATS="${CONFIG_PARTS[1]:-$FORMATS}"
              ARTIFACT_PLATFORMS="${CONFIG_PARTS[2]}"


              # Check if this directory has artifacts in the matrix
              DIR_FORMATS=$(echo "$ARTIFACT_MATRIX_JSON" | jq -r --arg dir "$DIR" '.include[] | select(.dir == $dir) | .format' | sort -u | tr '\n' ',' | sed 's/,$//')
              DIR_PLATFORMS=$(echo "$ARTIFACT_MATRIX_JSON" | jq -r --arg dir "$DIR" '.include[] | select(.dir == $dir) | .platform' | sort -u | tr '\n' ',' | sed 's/,$//')

              if [ -n "$DIR_FORMATS" ]; then
                echo "- **$DIR**:" >> "$GITHUB_STEP_SUMMARY"
                echo "  - **Formats**: $DIR_FORMATS" >> "$GITHUB_STEP_SUMMARY"
                echo "  - **Platforms**: $DIR_PLATFORMS" >> "$GITHUB_STEP_SUMMARY"

                # List the artifact images
                IFS=',' read -ra FORMAT_ARRAY <<< "$DIR_FORMATS"
                for FORMAT in "${FORMAT_ARRAY[@]}"; do
                  echo "  - **Image**: \`${{ env.DEST_REGISTRY_HOST }}/${{ env.DEST_REGISTRY_USER }}/bootc-$DIR-$FORMAT:{latest | vN}\`" >> "$GITHUB_STEP_SUMMARY"
                done
              fi
            done
          else
            echo "### Installable Artifacts" >> "$GITHUB_STEP_SUMMARY"
            echo "No artifacts were built in this run." >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "### Configuration Notes" >> "$GITHUB_STEP_SUMMARY"
          echo "- Only directories with a Containerfile that changed (or whose contents changed) are built." >> "$GITHUB_STEP_SUMMARY"
          echo "- Deleted directories are ignored gracefully (no build attempted)." >> "$GITHUB_STEP_SUMMARY"
          echo "- Version tags are created as vN (and vN-<arch> for platform images)." >> "$GITHUB_STEP_SUMMARY"
          echo "- Platform restrictions can be specified using a \`.buildconfig\` file in each directory." >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "#### .buildconfig options:" >> "$GITHUB_STEP_SUMMARY"
          echo "- \`platforms: linux/amd64,linux/arm64\` - Restrict platforms for both bootc images and artifacts (default: linux/amd64,linux/arm64)" >> "$GITHUB_STEP_SUMMARY"
          echo "- \`artifacts: true|false|auto\` - Enable/disable artifact creation (default: auto - create if none exist)" >> "$GITHUB_STEP_SUMMARY"
          echo "- \`artifact_formats: anaconda-iso,qcow2,vmdk,raw,ami,vhd,gce\` - Specify artifact formats" >> "$GITHUB_STEP_SUMMARY"